# SDS

简单动态字符串

### 结构

```json
struct sdshdr {
    int len;      // 已使用的字节数（字符串实际长度）
    int alloc;    // 分配的总容量
    char buf[];   // 真正存放字符串的字节数组，最后必有 '\0'
};
```

## 优点

1. 获取字符串长度的时间复杂度为 O(1)
2. 可以保存二进制数据

# 压缩表

## 结构

```tex
+-------------+-------------+-------------+-------------+-------------+---------+
| zlbytes(4B) | zltail(4B)  | zllen(2B)   | entry1      | entry2 ...  | zlend(1B)
+-------------+-------------+-------------+-------------+-------------+---------+
```

- **zlbytes**：整个 ziplist 占用的字节数。
- **zltail**：最后一个 entry 的起始位置偏移量，方便从尾部快速访问。
- **zllen**：entry 的数量（如果超过 65535，需要遍历计算）。
- **entryX**：存储的每个元素（可以是字符串或整数）。
- **zlend**：特殊标志字节 0xFF，表示 ziplist 结束。

### **entry 的内部结构**

```tex
+------------------+--------------------+-------------------+
| prevlen (1或5B)  | encoding & length  | content (数据内容)|
+------------------+--------------------+-------------------+
```

- **prevlen**：前一个 entry 的长度
	- 如果前一个 entry < 254 字节 → 用 1 字节存储
	- 如果 ≥ 254 字节 → 用 5 字节存储（第一个字节 254 + 后 4 字节记录长度）
	- 作用：方便从后往前遍历 ziplist。
- **encoding & length**：记录本 entry 存储的数据类型（字符串/整数）和长度。
- **content**：实际存储的数据内容。

##  优点

1. **紧凑存储**：多个 entry 连续排布，没有额外指针开销。
2. **双向遍历**：通过 prevlen 字段，可以实现从尾部向前遍历。

## 缺点 连锁更新问题

每一个 entry 节点内部都会保存前一个节点的长度，并且保存长度这个属性的空间大小还不是固定的

- 如果前一个 entry < 254 字节 → 用 1 字节存储
- 如果 ≥ 254 字节 → 用 5 字节存储（第一个字节 254 + 后 4 字节记录长度）

当在 连续的 entry 节点中插入或删除一个节点，可能导致后续所有节点的容量发生变化，引起连锁扩容问题，导致性能下降

新版 redis 使用 **listpack** 替代 压缩表来解决这个问题

# quikList

![image-20250817173212053](./image/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84//image-20250817173212053.png)

本质是 压缩表 + 双向链表， 每个节点对应一个压缩表

# 跳表

典型的以空间换时间, 查找的平均复杂度为 logN, 最坏时间复杂度为 N

## **底层数据结构**

- 跳表由多层结构构成
- 每一层都是一个有序链表
- 查找是从最顶层开始
- 最底层包含所有元素
- 如果一个元素出现在第 i 层, 那么在 第 i 以下的所有层都会出现
- 每个节点都有两个指针, 一个指向同一层的下个元素, 另一个指向下一层的元素

相比于平衡树, 跳跃表的实现更简单, 插入,删除时不会有复杂的平衡过程

![image-20250817173448912](./image/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84//image-20250817173448912.png)