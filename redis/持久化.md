# AOF

AOF 是写后日志，redis 先执行命令，再写入

## AOF 采用写后日志的好处

1. 先让系统执行再写日志，可以保证记录的命令都是正确的
2. 命令在执行后再记录日志，不会阻塞当前的写操作

## AOF 的风险

1. 执行后再写入，如果执行后系统宕机，就会导致数据丢失，因为此时还没写日志
2. 写后日志虽然不会阻塞当前操作，但可能会阻塞后续操作。因为写AOF 日志也是主线程，如果日志写入磁盘较慢，就可能会阻塞后续写操作

## AOF的回写策略，配置文件：appendfsync 参数

| 回写策略 | 时机                                 | 优点             | 缺点                 |
| :------- | :----------------------------------- | :--------------- | :------------------- |
| Always   | 同步写回，每个命令执行完后立即写日志 | 数据基本不会丢失 | 性能影响较大         |
| Everysec | 每秒写一次                           | 性能适中         | 有一定丢失数据的风险 |
| No       | 不写回，由操作系统控制写回           | 性能最好         | 丢失数据风险最高     |

## AOF 重写机制

AOF 是写后日志，每个修改数据的操作命令都会记录日志，所以日志会不可避免的膨胀。但是当我们多次修改同一个数据时，后一次操作很可能会覆盖前几次操作，对应的前几次操作的日志就是无用的。

因此，会重写 AOF 日志，重写时，AOF 文件只会记录键值对当前最新的数据对应的写命令

### AOF 重写会阻塞主线程吗

不会阻塞，会 Fork 出一个子进程，只是在 fork 子进程这个短暂瞬间出现阻塞，由子进程执行重写

### 重写期间，如果有新的写操作，会怎样

重写前，会先 copy 出一份 redis 的内存数据，基于这个内存数据进行重写。

重写时，如果有新的写操作，这个写操作执行后会写两份日志，一份是 AOF 本身的日志，一份重写的日志

# RDB

RDB 是内存快照。它保存当前 redis 在内存中全部数据的快照

## 生成RDB文件的两种方式

1. save：在主线程中进行，会阻塞写操作
2. bgsave：fork 出一个子进程。redis的默认配置

## bgsave 快照时，redis还能处理别的的写操作吗

bgsave 是不会阻塞主线程的。如果在快照时，还有别的写操作，redis 会依赖操作系统的 **写时复制**，在执行快照的同时，处理写操作。

bgsave 是 fork 出的子进程，可以共享主线程的内存数据，bgsave 开始后，会读取内存数据，写入 RDB 文件，如果此时有新的写操作，写操作修改的数据，会被复制一份生成一个副本数据，bgsave 也会把这个副本数据写入到 RDB 文件中

## RDB的触发时机

1. 定时触发，在配置文件中是 save 参数决定

	save [触发时间间隔] [被修改的键的规模]

2. 执行 bgsave，save 手动触发
3. 关闭 redis 时自动触发

# 混合存储

依旧是定期保存一下快照，但是在两次快照的时间间隔内，记录 AOF 命令。

这样既可以利用 RDB 的优点快速恢复 redis 中的数据，又可以利用 AOF 的优点保证数据不丢失

每次 AOF 重写时，会触发一次 RDB 保存快照，并把 快照的内容保存在 AOF 文件的开头



## 混合存储的缺点

AOF 文件前部分保存的是 RDB 的快照数据，导致 AOF 文件的可读性降低